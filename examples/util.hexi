# hexiscript util functions
if catch UTIL_HEXI # Like #ifndef in C

# Consts
fun UTIL_HEXI; return true; endfun
fun null;      return 0; endfun
fun pi;        return 3.141592654; endfun

# TODO: Add assertions to all library functions where needed
fun assert a s; if !a; println "Assert_Error Message: " + s; throw Assert_Error; endif; endfun

fun to_upper s
  let out ""
  let l   len s
  for let i 0; i < l; i++
    if s[i] >= 'a' && s[i] <= 'z'
      let out (out + tochar (s[i] - 32))
    else
      let out (out + s[i])
    endif
  endfor
  return out
endfun

fun to_lower s
  let out ""
  let l   len s
  for let i 0; i < l; i++
    if s[i] >= 'A' && s[i] <= 'Z'
      let out (out + tochar (s[i] + 32))
    else
      let out (out + s[i])
    endif
  endfor
  return out
endfun

fun toint s
  let n tonum s
  if catch n; return n; endif
  return floor n
endfun

fun tofloat s
  let n tonum s
  if catch n; return n; endif
  return n + 0.
endfun

fun string_filter s elem
  let out ""
  for let i 0; i < len s; i++
    if s[i] != elem
      let out (out + s[i])
    endif
  endfor
  return out
endfun

fun string_trim s
  let out ""
  for let i 0; i < len s - 1; i++
    if s[i] != ' '; break; endif
  endfor
  for let j len s - 1; j >= 0; j--
    if s[j] != ' '; break; endif
  endfor
  for let k i; k <= j; k++
    let out (out + s[k])
  endfor
  return out
endfun

fun string_compare a b
  let min_l len a
  if len b < len a; let min_l len b; endif
  for let i 0; i < min_l; i++
    if a[i] != b[i]; return a[i] - b[i]; endif
  endfor
  return len a - len b
endfun

fun string_split s delim
  let ret    dict 32
  let l      len s
  let j      0
  let ret[0] ""
  for let i 0; i < l; i++
    if s[i] = delim
      if len ret[j] > 0
        let ret[++j] ""
      endif
      continue
    endif
    let ret[j] (ret[j] + s[i])
  endfor
  return ret
endfun

fun string_sub s from to
  let ls len s
  assert (0 <= from && from <= to && to <= ls) ("string_sub: from=" + from + ", to=" + to)
  let ret ""
  for let i from; i < to; i++
    let ret (ret + s[i])
  endfor
  return ret
endfun

fun nat_order a b
  if a > b
    return 1
  elif a < b
    return (-1)
  else
    return 0
  endif
endfun

fun rev_order a b
  if a > b
    return (-1)
  elif a < b
    return 1
  else
    return 0
  endif
endfun

# Overwrite compare for general types
fun compare a b; return nat_order a b; endfun

fun min x y; if compare y x < 0; return y; else return x; endif; endfun

fun max x y; if compare x y < 0; return y; else return x; endif; endfun

fun dict_copy d
  let n   len d
  let k   keys d
  let cpy dict n
  for let i 0; i < n; i++
    let cpy[k[i]] d[k[i]]
  endfor
  return cpy
endfun

fun dict_print d
  let n len d
  let k keys d
  for let i 0; i < n; i++
    print k[i] + "\t: "
    println d[k[i]]
  endfor
endfun

# Array functions
# Most array functions work with dicts as well
fun array_copy a
  let n   len a
  let cpy arr n
  for let i 0; i < n; i++
    let cpy[i] a[i]
  endfor
  return cpy
endfun

fun array_filter a elem
  let n     len a
  let out   dict n
  let index 0
  for let i 0; i < n; i++
    if compare a[i] elem != 0
      let out[index++] a[i]
    endif
  endfor
  return array_copy out
endfun

fun array_fill a elem
  let n len a
  for let i 0; i < n; i++
    let a[i] elem
  endfor
endfun

fun array_print a
  let n len a - 1
  if n < 0
    println "{}"
  else
    print "{"
    for let i 0; i < n; i++
      print tostr a[i] + ", "
    endfor
    print tostr a[n] + "}"
  endif
endfun

fun array_println a; array_print a; println ""; endfun

fun array_sort h
  fun sift_down h n index
    while index * 2 + 1 < n
      let child index * 2 + 1
      if child + 1 < n
        if compare h[child] h[child + 1] < 0
          child++
        endif
      endif
      if compare h[index] h[child] < 0
        let tmp       h[index]
        let h[index]  h[child]
        let h[child]  tmp
        let index     child
      else
        break
      endif
    endwhile
  endfun
  let n len h
  # Initialize as heap
  for let i n / 2 - 1; i >= 0; i--
    sift_down h n i
  endfor
  # Poll elements until empty
  while n > 0
    let tmp  h[0]
    let h[0] h[--n]
    let h[n] tmp
    sift_down h n 0
  endwhile
endfun

fun array_concat a b
  let la len a
  let lb len b
  let c  arr (la + lb)
  for let i 0; i < la; i++
    let c[i] a[i]
  endfor
  for let i la; i < la + lb; i++
    let c[i] b[i - la]
  endfor
  return c
endfun

# Subset operation (Assumes sortedness!)
fun array_subset a b
  let la len a; let lb len b
  if lb < la; return false; endif
  for let i 0; i < la; i++
    let j 0
    while compare b[j] a[i] < 0; j++; endwhile
    if compare b[j] a[i] != 0; return false; endif
  endfor
  return true
endfun

# Intersect operation (Assumes sortedness!)
fun array_intersect a b
  let la len a; let lb len b
  if la = 0 || lb = 0; return arr 0; endif
  let x 0; let y 0; let r 0
  let res dict (la + lb)
  while x < la && y < lb
    if   compare a[x] b[y] < 0; x++
    elif compare b[y] a[x] < 0; y++
    elif a[x] = b[y]
      let res[r++] a[x]
      if x < la; x++; else y++; endif
    else
      break
    endif
  endwhile
  return array_copy res
endfun

fun folder acc x; return acc + x; endfun
fun array_fold acc a
  let la len a
  for let i 0; i < la; i++
    let acc (folder acc a[i])
  endfor
  return acc
endfun

fun array_sum a
  fun folder acc x; return acc + x; endfun
  return array_fold 0 a;
endfun

fun mapper x; return toint x; endfun
fun array_map a
  let la len a
  let a array_copy a
  for let i 0; i < la; i++
    let a[i] (mapper a[i])
  endfor
  return a
endfun

# Fast way to initialize arrays
fun array_quick s delim type
  let res string_split s delim
  let res array_copy res
  if type = "int"
    fun mapper x; return toint x; endfun
    let res array_map res
  elif type = "bool"
    fun mapper x; if x = "true"; return true; else return false; endif; endfun
    let res array_map res
  elif type = "float"
    fun mapper x; return tonum x; endfun
    let res array_map res
  elif type = "char"
    fun mapper x; return tochar x; endfun
    let res array_map res
  endif
  return res
endfun

fun array_member a x
  let la len a
  for let i 0; i < la; i++
    if a[i] = x; return true; endif
  endfor
  return false
endfun

fun array_sub a from to
  let la len a
  assert (0 <= from && from <= to && to <= la) ("array_sub: from=" + from + ", to=" + to)
  let ret arr (to - from)
  for let i from; i < to; i++
    let ret[i - from] a[i]
  endfor
  return ret
endfun

# Heap functions
# Uses function "compare" to determine ordering
fun heap_create size
  let heap         dict size
  let heap["size"] 0
  return heap
endfun

fun heap_insert heap elem
  fun sift_up heap index
    while (index - 1) / 2 >= 0
      let parent (index - 1) / 2
      if compare heap[parent] heap[index] > 0
        let tmp          heap[parent]
        let heap[parent] heap[index]
        let heap[index]  tmp
        let index        parent
      else
        break
      endif
    endwhile
  endfun
  let index       heap["size"]++
  let heap[index] elem
  sift_up heap index
endfun

fun heap_poll heap
  fun sift_down heap index
    while index * 2 + 1 < heap["size"]
      let child index * 2 + 1
      if child + 1 < heap["size"]
        if compare heap[child] heap[child + 1] > 0
          child++
        endif
      endif
      if compare heap[index] heap[child] > 0
        let tmp         heap[index]
        let heap[index] heap[child]
        let heap[child] tmp
        let index       child
      else
        break
      endif
    endwhile
  endfun
  if heap["size"] > 0
    let index   --heap["size"]
    let elem    heap[0]
    let heap[0] heap[index]
    sift_down heap 0
    return elem
  else
    println "Heap is empty!"
    return 0
  endif
endfun

# Unbalanced Binary Tree
fun tree_create init
  let t    arr  3
  let t[0] init
  let t[1] null
  let t[2] null
  return t
endfun
fun set_create init; return tree_create init; endfun
fun set_empty; return null; endfun

# Turns tree into (sorted) array (inorder)
fun tree_flatten t
  let elem 0; let left 1; let right 2
  if t = null; return arr 0
  else
    let e    arr 1
    let e[0] t[elem]
    let tl   (tree_flatten t[left] )
    let tr   (tree_flatten t[right])
    let tl   (array_concat tl e    )
    return array_concat tl tr
  endif
endfun
fun array_of_tree t; return tree_flatten t; endfun
fun array_of_set t; return tree_flatten t; endfun

# Turns array into tree (Assumes sortedness!)
fun tree_of_array a
  fun recurse a from to
    if to < from; return null; endif
    if to = from; return tree_create a[from]; endif
    let left 1; let right 2
    let pivot    from + (to - from) / 2
    let t        tree_create a[pivot]
    let t[left]  recurse a from (pivot - 1)
    let t[right] recurse a (pivot + 1) to
    return t
  endfun
  if len a = 0; return null; endif
  return recurse a 0 (len a - 1)
endfun
fun set_of_array a; return tree_of_array a; endfun

# Creates a balanced copy of t
fun tree_balance t; return tree_of_array (tree_flatten t); endfun
fun set_copy t; return tree_balance t; endfun

fun tree_insert t e
  let elem 0; let left 1; let right 2
  if 0 < compare t[elem] e
    if t[left] = null
      let t[left] (tree_create e)
    else
      tree_insert t[left] e
    endif
  elif compare t[elem] e < 0
    if t[right] = null
      let t[right] (tree_create e)
    else
      tree_insert t[right] e
    endif
  endif
  return t
endfun
fun set_insert t e; if t = null; return tree_create e; else return tree_insert t e; endif; endfun

fun tree_find t e
  let elem 0; let left 1; let right 2
  if t = null; return null; endif
  if 0 < compare t[elem] e
    return tree_find t[left] e
  elif compare t[elem] e < 0
    return tree_find t[right] e
  else
    return t
  endif
endfun
fun set_member t e; return null != tree_find t e; endfun

fun tree_min t
  let elem 0; let left 1; let right 2
  if t = null; return null
  elif t[left] = null; return t[elem]
  else return tree_min t[left]; endif
endfun
fun Min t; return tree_min t; endfun

fun tree_max t
  let elem 0; let left 1; let right 2
  if t = null; return null
  elif t[right] = null; return t[elem]
  else return tree_max t[right]; endif
endfun
fun Max t; return tree_max t; endfun

fun tree_delete t e
  let elem 0; let left 1; let right 2
  if t = null; return null; endif
  if 0 < compare t[elem] e
    let t[left] tree_delete t[left] e
  elif compare t[elem] e < 0
    let t[right]  tree_delete t[right] e
  else
    if t[right] = null; return t[left]
    else
      let min_t tree_min t[right]
      let t[right]     tree_delete t[right] min_t
      let t[elem]      min_t
    endif
  endif
  return t
endfun
fun set_delete t e; return tree_delete t e; endfun

fun tree_size t
  let left 1; let right 2
  if t = null; return 0
  else return tree_size t[left] + 1 + tree_size t[right]; endif
endfun
fun card t; return tree_size t; endfun

fun tree_print t; array_print tree_flatten t; endfun
fun tree_println t; array_println tree_flatten t; endfun
fun set_print t; tree_print t; endfun
fun set_println t; tree_println t; endfun

fun tree_join a b
  if b = null; return a; endif
  if a = null; return b; endif
  # Rebalance the larger tree, flatten the smaller
  if len a < len b
    let t tree_balance b
    let a tree_flatten a
  else
    let t tree_balance a
    let a tree_flatten b
  endif
  let l len a
  for let i 0; i < l; i++
    tree_insert t a[i]
  endfor
  return t
endfun
fun set_union a b; return tree_join a b; endfun

fun tree_subset a b; return array_subset (tree_flatten a) (tree_flatten b); endfun
fun set_subset a b; return tree_subset a b; endfun

fun tree_intersect a b; return tree_of_array array_intersect (tree_flatten a) (tree_flatten b); endfun
fun set_intersect a b; return tree_intersect a b; endfun

fun tree_delete_array t a
  let la len a
  for let i 0; i < la; i++
    let t tree_delete t a[i]
  endfor
  return t
endfun

fun tree_delete_tree a b; return tree_delete_array a (tree_flatten b); endfun
fun set_minus a b; return tree_delete_tree a b; endfun

fun tree_sum t
  let elem 0; let left 1; let right 2
  if t = null; return 0; endif
  return tree_sum t[left] + t[elem] + tree_sum t[right]
endfun
fun set_sum t; return tree_sum t; endfun

fun tree_quick s delim type
  let s  array_quick s delim type
  let ls len s
  if ls = 0; return null; endif
  let res tree_create s[0]
  for let i 1; i < ls; i++
    tree_insert res s[i]
  endfor
  return tree_balance res
endfun
fun set_quick s delim type; return tree_quick s delim type; endfun

fun tree_fold acc t; return array_fold acc (array_of_tree t); endfun
fun set_fold acc t; return tree_fold acc t; endfun

# Compare sets using string_compare
fun set_compare a b
  fun folder acc x; return acc + x; endfun
  let sa array_of_set a
  let sb array_of_set b
  let sa (array_fold "" sa)
  let sb (array_fold "" sb)
  return string_compare sa sb
endfun

# Split string using multiple delimiters (char set!)
fun string_splits s delims
  let ret    dict 32
  let l      len s
  let j      0
  let ret[0] ""
  for let i 0; i < l; i++
    if set_member delims s[i]
      if len ret[j] > 0
        let ret[++j] ""
      endif
      continue
    endif
    let ret[j] (ret[j] + s[i])
  endfor
  return ret
endfun

# Linked List
fun list_create init
  let l    arr 2
  let l[0] init
  let l[1] null
  return l
endfun
fun stack_create init; return list_create init; endfun

fun list_prepend l e
  let h    (list_create e)
  let h[1] l
  return h
endfun
fun stack_push s e; return list_prepend s e; endfun

fun list_append l e
  if l[1] = null; let l[1] (list_create e)
  else list_append l[1] e; endif
endfun

fun list_head l
  if l = null; return null; endif
  return l[0]
endfun
fun stack_poll s; return list_head s; endfun

fun list_poll l i
  if l = null; return null; endif
  if i <= 0; return l[0]; endif
  return list_poll l[1] (i - 1)
endfun

fun list_pop l i
  if l = null; return null; endif
  if i <= 0; return l[1]; endif
  let l[1] list_pop l[1] (i - 1)
  return l
endfun

fun stack_pop s
  if s = null; return null; endif
  return s[1]
endfun

fun list_size l
  if l = null; return 0; endif
  return 1 + list_size l[1]
endfun
fun stack_size s; return list_size s; endfun

fun array_of_list l
  if l = null; return arr 0; endif
  let e arr 1; let e[0] l[0]
  return array_concat e (array_of_list l[1])
endfun

fun list_of_array a
  if len a = 0; return null; endif
  let la len a - 1
  let l list_create a[la--]
  while 0 <= la
    let l list_prepend l a[la--]
  endwhile
  return l
endfun

fun list_print l; array_print (array_of_list l); endfun
fun list_println l; array_println (array_of_list l); endfun
fun stack_print s; list_print s; endfun
fun stack_println s; stack_print s; endfun

fun list_quick s delim type
  let a array_quick s delim type
  return list_of_array a
endfun

fun list_map l; return list_of_array (array_map (array_of_list l)); endfun
fun stack_map s; return list_map s; endfun
fun list_fold acc l; return array_fold acc (array_of_list l); endfun
fun stack_fold acc s; return list_fold acc s; endfun

endif # UTIL_HEXI
